# 자동차 경주 게임
## 진행 방법
* 자동차 경주 게임 요구사항을 파악한다.
* 요구사항에 대한 구현을 완료한 후 자신의 github 아이디에 해당하는 브랜치에 Pull Request(이하 PR)를 통해 코드 리뷰 요청을 한다.
* 코드 리뷰 피드백에 대한 개선 작업을 하고 다시 PUSH한다.
* 모든 피드백을 완료하면 다음 단계를 도전하고 앞의 과정을 반복한다.

## 온라인 코드 리뷰 과정
* [텍스트와 이미지로 살펴보는 온라인 코드 리뷰 과정](https://github.com/next-step/nextstep-docs/tree/master/codereview)

## 문자열 계산기 기능 목록
- 입력된 내용 validation 확인 (Validator)
  - [x] 입력값이 null 이거나 빈 공백 문자일 경우 예외처리
  - [x] 사칙연산 기호가 아닌 경우 예외 처리 
- 연산 실행 (Calculator)
  - [x] 사칙연산 메소드 생성
  - [x] 사칙연산 메소드 호출을 통한 전체 연산 실행

## 자동차 경주 기능 목록
- 차 생성 CarGenerator
  - [x] 자동차 수와 이름 입력 받아 자동차 리스트 생성
- 차 클래스 Car
  - [x] 자동차 이름 길이 확인
  - [x] 이동 가능 여부 확인
  - [x] 이동
  - [x] 현위치 출력
- 경주 클래스 Race
  - [x] 라운드 횟수 입력 받기
  - [x] 라운드 수만큼 레이스 실행
  - [x] 최종 결과 출력



## 피드백 사항

1. 사용하지 않는 주석의 제거
2. 입력과 생성의 분리 (carRacing)
3. 계산기에 대한 application 생성
4. 생성자를 사용하여 초기화하는 것, 그리고 그 차이
5. Calculator의 execute 로직 분리
   - 생성자를 통한 상태 값 초기화
   - 비지니스 로직 분리
6. else를 사용하지 않는 calculate -> enum을 사용하여 구현
7. 단순한 유효성 검사의 기능을 가진 객체의 역할 추가. 
8. validateNameLength 매직넘버를 사용하지 않도록 상수화
9. Car 객체의 UI로직의 분리
10. moveCheck 함수를 테스트 가능하도록 테스트 불가능한 로직과 분리하여 구현
11. createCar 함수 내에 로직 분리
    - 데이터 입력
    - 객체 생성
    - 비지니스 로직
12. Racing의 단위 테스트 추가
13. 일급컬렉션, 컬렉션을 상태값으로 가지면 어떠한 이점이 있는가?
14. race() 함수의 
15. setRoundNumber() 함수의 로직 분리
    - 데이터 입력
    - 비지니스 로직
16. 우승자만을 위한 별도의 객체로 분리하기
