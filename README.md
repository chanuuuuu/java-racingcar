# 자동차 경주 게임
## 진행 방법
* 자동차 경주 게임 요구사항을 파악한다.
* 요구사항에 대한 구현을 완료한 후 자신의 github 아이디에 해당하는 브랜치에 Pull Request(이하 PR)를 통해 코드 리뷰 요청을 한다.
* 코드 리뷰 피드백에 대한 개선 작업을 하고 다시 PUSH한다.
* 모든 피드백을 완료하면 다음 단계를 도전하고 앞의 과정을 반복한다.

## 온라인 코드 리뷰 과정
* [텍스트와 이미지로 살펴보는 온라인 코드 리뷰 과정](https://github.com/next-step/nextstep-docs/tree/master/codereview)

## 문자열 계산기 기능 목록
- 입력된 내용 validation 확인 (Validator)
  - [x] 입력값이 null 이거나 빈 공백 문자일 경우 예외처리
  - [x] 사칙연산 기호가 아닌 경우 예외 처리 
- 연산 실행 (Calculator)
  - [x] 사칙연산 메소드 생성
  - [x] 사칙연산 메소드 호출을 통한 전체 연산 실행
- 연산에 필요한 검증 수행 (Validator)
  - [x] 초기 조건인 null, 공백 문자열에 대한 검증
  - [x] 연산자의 유효성 검증

## 자동차 경주 기능 목록
- 차 생성 CarGenerator
  - [x] 자동차 수와 이름 입력 받아 자동차 리스트 생성
- 차 클래스 Car
  - [x] 자동차 이름 길이 확인
  - [x] 이동 가능 여부 확인
  - [x] 이동
  - [x] 현위치 출력
- Car 인스턴스의 배열을 가진 일급 컬랙션 Cars
  - [x] Car 인스턴스 배열
  - [x] 자동차의 갯수
  - [x] 라운드별 자동차의 거리 
  - [x] 라운드 수행
- 경주 클래스 Race
  - [x] 라운드 횟수 입력 받기
  - [x] 라운드 수만큼 레이스 실행
  - [x] 최종 결과 출력



### 피드백 사항

1. 사용하지 않는 주석의 제거
2. 입력과 생성의 분리 (carRacing)
3. 계산기에 대한 application 생성
4. 생성자를 사용하여 초기화하는 것, 그리고 그 차이
5. Calculator의 execute 로직 분리
   - 생성자를 통한 상태 값 초기화
   - 비지니스 로직 분리
6. else를 사용하지 않는 calculate -> enum을 사용하여 구현
7. 단순한 유효성 검사의 기능을 가진 객체의 역할 추가. 
8. validateNameLength 매직넘버를 사용하지 않도록 상수화
9. Car 객체의 UI로직의 분리
10. moveCheck 함수를 테스트 가능하도록 테스트 불가능한 로직과 분리하여 구현
11. createCar 함수 내에 로직 분리
    - 데이터 입력
    - 객체 생성
    - 비지니스 로직
12. Racing의 단위 테스트 추가
13. 일급컬렉션, 컬렉션을 상태값으로 가지면 어떠한 이점이 있는가?
14. race() 함수의 
15. setRoundNumber() 함수의 로직 분리
    - 데이터 입력
    - 비지니스 로직
16. 우승자만을 위한 별도의 객체로 분리하기


### 2차 피드백 사항

- [x] List<Car>를 포장하는 객체 구현
    > 일급 컬렉션을 사용하여 구현 (Cars)
- [x] 연산 작업을 switch문이 아닌 map을 통한 처리
    > enum과 steam을 사용하여 연산자에 따른 동작 수행하도록 구현
- [x] eum Operator에 대한 파일 분리
- [x] Validator의 white space에 대한 매직넘버 처리
- [x] Car의 단위 테스트를 위한 랜덤 값에 대한 의존성 제거
- [x] CarGenerator -> 일급 컬렉션 Cars의 사용
- [x] Car의 상태 변수 roundScore, distance의 중복성 제거 
